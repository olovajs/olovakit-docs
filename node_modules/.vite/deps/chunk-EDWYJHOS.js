// node_modules/olovakit/dist/olovakit.js
var rootComponent;
var rootContainer;
var previousVDOM;
var currentComponent;
var componentStateMap = /* @__PURE__ */ new Map();
var contextProviders = /* @__PURE__ */ new Map();
var currentContextKey = 0;
var SVG_TAGS = /* @__PURE__ */ new Set(["svg", "path", "circle", "rect", "line", "polygon", "polyline", "ellipse", "g", "text", "defs", "filter", "mask", "marker", "pattern", "linearGradient", "radialGradient", "stop", "use", "clipPath", "textPath", "tspan", "foreignObject"]);
var LRUCache = class {
  constructor(e) {
    this.maxSize = e, this.cache = /* @__PURE__ */ new Map(), this.keyOrder = [];
  }
  get(e) {
    if (this.cache.has(e)) return this.keyOrder = this.keyOrder.filter((t) => t !== e), this.keyOrder.push(e), this.cache.get(e);
  }
  set(e, t) {
    if (this.cache.has(e)) this.keyOrder = this.keyOrder.filter((t2) => t2 !== e);
    else if (this.cache.size >= this.maxSize) {
      const e2 = this.keyOrder.shift();
      this.cache.delete(e2);
    }
    return this.cache.set(e, t), this.keyOrder.push(e), t;
  }
  has(e) {
    return this.cache.has(e);
  }
};
var renderCache = new LRUCache(100);
function memoizeRender(e, t, n) {
  const r = `${n}-${JSON.stringify(t)}`;
  if (renderCache.has(r)) return renderCache.get(r);
  const o = e(t);
  return renderCache.set(r, o);
}
function createElement(e, t, ...n) {
  t = t || {};
  let r = n.flat(1 / 0).filter((e2) => true !== e2 && false !== e2).map((e2) => null == e2 ? createTextElement("") : "object" == typeof e2 ? e2 : createTextElement(e2));
  if (void 0 !== t.children) {
    r = (Array.isArray(t.children) ? t.children : [t.children]).flat(1 / 0).filter((e2) => true !== e2 && false !== e2).map((e2) => null == e2 ? createTextElement("") : "object" == typeof e2 ? e2 : createTextElement(e2));
  }
  const o = { ...t };
  return delete o.children, { type: e, props: { ...o, children: r } };
}
function createTextElement(e) {
  return { type: "TEXT", props: { nodeValue: String(e), children: [] } };
}
function setState(e) {
  const t = currentComponent, n = t.hookIndex++;
  if (!t.hooks[n]) {
    const r2 = "function" == typeof e ? e() : e;
    t.hooks[n] = { state: r2 };
  }
  const r = t.hooks[n];
  return [r.state, (e2) => {
    const t2 = "function" == typeof e2 ? e2(r.state) : e2;
    if (t2 !== r.state) {
      const e3 = () => {
        r.state = t2;
      };
      isBatchingUpdates ? pendingStateUpdates.push(e3) : (e3(), renderApp());
    }
  }];
}
function setReducer(e, t, n) {
  const [r, o] = o(n ? () => n(t) : t);
  return [r, (t2) => {
    o((n2) => e(n2, t2));
  }];
}
function setMemo(e, t) {
  const n = currentComponent, r = n.hookIndex++;
  if (!n.hooks[r]) return n.hooks[r] = { value: e(), deps: t }, n.hooks[r].value;
  const o = n.hooks[r];
  return arraysEqual(o.deps, t) || (o.value = e(), o.deps = t), o.value;
}
function setCallback(e, t) {
  return setMemo(() => e, t);
}
function setEffect(e, t) {
  const n = currentComponent, r = n.hookIndex++;
  n.hooks[r] || (n.hooks[r] = { effect: e, deps: null, cleanup: null });
  const o = n.hooks[r];
  arraysEqual(o.deps, t) || (o.cleanup && setTimeout(() => {
    "function" == typeof o.cleanup && o.cleanup();
  }, 0), o.effect = e, o.deps = t, setTimeout(() => {
    const t2 = e();
    o.cleanup = t2;
  }, 0));
}
function createContext(e) {
  const t = currentContextKey++;
  return { Provider: function(e2) {
    const { value: n, children: r } = e2;
    return setEffect(() => (contextProviders.set(t, n), () => {
      contextProviders.get(t) === n && contextProviders.delete(t);
    }), [n]), r;
  }, Consumer: function(e2) {
    return e2.children(setContext(this));
  }, _contextId: t, _defaultValue: e };
}
function setContext(e) {
  return setEffect(() => () => {
  }, [contextProviders.get(e._contextId)]), void 0 !== contextProviders.get(e._contextId) ? contextProviders.get(e._contextId) : e._defaultValue;
}
function setRef(e) {
  const t = currentComponent, n = t.hookIndex++;
  return t.hooks[n] || (t.hooks[n] = { current: e }), t.hooks[n];
}
function arraysEqual(e, t) {
  if (e === t) return true;
  if (null == e || null == t) return false;
  if (e.length !== t.length) return false;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return false;
  return true;
}
function Fragment(e) {
  return e.children;
}
function buildVDOM(e, t) {
  if (!e) return null;
  if (Array.isArray(e)) return { type: Fragment, props: { children: e.map((e2, n) => buildVDOM(e2, t.concat(n))) } };
  try {
    if ("object" != typeof e) return createTextElement(String(e));
    if (e.type === Fragment) return { type: Fragment, props: { children: Array.isArray(e.props.children) ? e.props.children.map((e2, n) => buildVDOM(e2, t.concat(n))) : [buildVDOM(e.props.children, t.concat(0))] } };
    if ("string" == typeof e.type || "TEXT" === e.type) {
      const n = Array.isArray(e.props.children) ? e.props.children.map((e2, n2) => buildVDOM(e2, t.concat(n2))) : [buildVDOM(e.props.children, t.concat(0))];
      return { type: e.type, props: { ...e.props, children: n } };
    }
    if ("function" != typeof e.type) return console.warn("Invalid vdom type:", e), createTextElement("");
    {
      const n = t.join(".");
      let r = componentStateMap.get(n);
      r || (r = { hooks: [], hookIndex: 0 }, componentStateMap.set(n, r)), currentComponent = r, currentComponent.hookIndex = 0, currentComponent._pathKey = n, e._pathKey = n;
      try {
        const r2 = e.type.isPure || e.type.name && e.type.name.startsWith("Memo"), o = { ...e.props };
        return buildVDOM(r2 ? memoizeRender(e.type, o, n) : e.type(o), t);
      } catch (e2) {
        return console.error("Error rendering component:", e2), createElement("div", { className: "error-boundary" }, `Component Error: ${e2.message}`);
      }
    }
  } catch (t2) {
    return console.error("Error in buildVDOM:", t2, "for vdom:", e), createElement("div", { className: "error-boundary" }, `Rendering Error: ${t2.message}`);
  }
}
function createDOM(e) {
  if (!e) return document.createComment("empty node");
  if ("TEXT" === e.type) return document.createTextNode(e.props.nodeValue);
  if (e.type === Fragment) {
    const t2 = document.createDocumentFragment();
    return e.props.children.filter((e2) => null != e2).forEach((e2) => {
      const n2 = createDOM(e2);
      n2 && t2.appendChild(n2);
    }), t2;
  }
  const t = SVG_TAGS.has(e.type), n = t ? document.createElementNS("http://www.w3.org/2000/svg", e.type) : document.createElement(e.type);
  return e.props && e.props.dangerouslySetInnerHTML ? n.innerHTML = e.props.dangerouslySetInnerHTML.__html || "" : (applyProps(n, {}, e.props, t), e.props.children.filter((e2) => null != e2).forEach((e2) => {
    const t2 = createDOM(e2);
    t2 && n.appendChild(t2);
  })), e.dom = n, n;
}
function applyProps(e, t = {}, n = {}, r = false) {
  if (e && "function" == typeof e.setAttribute) {
    if (n.ref && (n.ref.current = e), n.style) try {
      const t2 = n.style;
      Object.keys(t2).forEach((n2) => {
        e.style[n2] = t2[n2];
      });
    } catch (e2) {
      console.error("Error applying styles:", e2);
    }
    if (n.className) try {
      r ? e.setAttribute("class", n.className) : e.className = n.className;
    } catch (e2) {
      console.error("Error setting className:", e2);
    }
    if (n.dangerouslySetInnerHTML) e.innerHTML = n.dangerouslySetInnerHTML.__html || "";
    else {
      !("value" in n) || "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName && "SELECT" !== e.tagName || (e.value = null == n.value ? "" : n.value), "checked" in n && "INPUT" === e.tagName && (e.checked = !!n.checked);
      for (const [o, s] of Object.entries(n)) try {
        if ("children" !== o && "ref" !== o && "style" !== o && "className" !== o && "dangerouslySetInnerHTML" !== o && "value" !== o && "checked" !== o) if (o.startsWith("on") && "function" == typeof s) {
          const n2 = o.toLowerCase().substring(2);
          t[o] && t[o] !== s && e.removeEventListener(n2, t[o]), e.addEventListener(n2, s);
        } else "function" != typeof s && "object" != typeof s && (r ? e.setAttribute(o, s) : o in e ? e[o] = s : e.setAttribute(o, s));
      } catch (e2) {
        console.error(`Error setting attribute ${o}:`, e2);
      }
    }
  }
}
function cleanupComponent(e) {
  const t = componentStateMap.get(e);
  t && (t.hooks.forEach((e2) => {
    e2.cleanup && "function" == typeof e2.cleanup && e2.cleanup();
  }), componentStateMap.delete(e));
}
function updateDOM(e, t, n, r = 0) {
  if (e && e.childNodes) {
    if (Array.isArray(t) && Array.isArray(n)) {
      const o = /* @__PURE__ */ new Map(), s = [];
      t.forEach((e2, t2) => {
        e2 && e2.props && e2.props.key ? o.set(e2.props.key, t2) : s.push(t2);
      });
      let c = 0;
      return n.forEach((n2, a) => {
        if (n2 && n2.props && n2.props.key && o.has(n2.props.key)) {
          const r2 = o.get(n2.props.key);
          updateDOM(e, t[r2], n2, r2), t[r2] = null;
        } else {
          const o2 = s[c++] || r + a;
          updateDOM(e, t[o2], n2, o2), o2 < t.length && (t[o2] = null);
        }
      }), void t.forEach((t2, n2) => {
        null !== t2 && updateDOM(e, t2, null, n2);
      });
    }
    if ((t == null ? void 0 : t.type) !== Fragment || (n == null ? void 0 : n.type) !== Fragment) {
      if (n && "PORTAL" === n.type) {
        const e2 = n.props.container;
        if (t && "PORTAL" === t.type) {
          const e3 = Math.max(t.props.children.length, n.props.children.length);
          for (let r2 = 0; r2 < e3; r2++) updateDOM(t.props.container, t.props.children[r2], n.props.children[r2], r2);
        } else n.props.children.forEach((t2, n2) => {
          updateDOM(e2, null, t2, n2);
        });
      } else if (!t && n) {
        const t2 = createDOM(n);
        t2 && (e.childNodes.length <= r ? e.appendChild(t2) : e.insertBefore(t2, e.childNodes[r]));
      } else if (t && !n) {
        if (e.childNodes[r] && e.removeChild(e.childNodes[r]), "function" == typeof t.type) {
          const e2 = t._pathKey;
          e2 && cleanupComponent(e2);
        }
      } else if (t && n && t.type !== n.type) {
        const t2 = createDOM(n);
        t2 && (r < e.childNodes.length ? e.replaceChild(t2, e.childNodes[r]) : e.appendChild(t2));
      } else if (t && n) {
        if ("TEXT" === n.type) {
          if (r < e.childNodes.length) {
            const o = e.childNodes[r];
            t.props.nodeValue !== n.props.nodeValue && (o.nodeValue = n.props.nodeValue), n.dom = o;
          }
        } else if (r < e.childNodes.length) {
          const o = e.childNodes[r], s = SVG_TAGS.has(n.type);
          for (const e2 in t.props) "children" === e2 || e2 in n.props || (e2.startsWith("on") ? o.removeEventListener(e2.toLowerCase().substring(2), t.props[e2]) : "style" === e2 ? o.removeAttribute("style") : "ref" !== e2 && o.removeAttribute(e2));
          applyProps(o, t.props, n.props, s);
          const c = Math.max(t.props.children.length, n.props.children.length);
          for (let e2 = 0; e2 < c; e2++) updateDOM(o, t.props.children[e2], n.props.children[e2], e2);
          n.dom = o;
        }
      }
    } else {
      const o = Math.max(t.props.children.length, n.props.children.length);
      for (let s = 0; s < o; s++) updateDOM(e, t.props.children[s], n.props.children[s], r + s);
    }
  } else console.warn("Invalid parent DOM in updateDOM:", e);
}
function debounce(e, t) {
  let n;
  return function(...r) {
    clearTimeout(n), n = setTimeout(() => {
      clearTimeout(n), e(...r);
    }, t);
  };
}
var renderQueued = false;
function render(e, t) {
  rootComponent = e, rootContainer = t, renderApp();
}
var concurrentMode = false;
var currentPriority = 0;
var PRIORITY = { IMMEDIATE: 99, USER_BLOCKING: 98, NORMAL: 97, LOW: 96, IDLE: 95 };
function enableConcurrentMode() {
  concurrentMode = true;
}
function scheduleWork(e, t = PRIORITY.NORMAL) {
  concurrentMode ? (currentPriority = t, t === PRIORITY.IMMEDIATE ? e() : t === PRIORITY.USER_BLOCKING ? setTimeout(e, 0) : t === PRIORITY.NORMAL ? setTimeout(e, 10) : t === PRIORITY.LOW ? setTimeout(e, 100) : t === PRIORITY.IDLE && (requestIdleCallback ? requestIdleCallback(e) : setTimeout(e, 500))) : e();
}
var renderApp = debounce(() => {
  if (renderQueued) return;
  renderQueued = true;
  const e = () => {
    try {
      renderQueued = false;
      const e2 = buildVDOM("object" == typeof rootComponent && rootComponent.type ? rootComponent : createElement(rootComponent, null), []);
      if (updateDOM(rootContainer, previousVDOM, e2), previousVDOM = e2, pendingStateUpdates.length > 0) {
        const e3 = [...pendingStateUpdates];
        pendingStateUpdates.length = 0, e3.forEach((e4) => e4()), renderApp();
      }
    } catch (e2) {
      console.error("Error during render:", e2), renderQueued = false;
    }
  };
  concurrentMode ? scheduleWork(e, currentPriority || PRIORITY.NORMAL) : queueMicrotask(e);
}, 16);
function memo(e, t) {
  function n(n2) {
    const r = currentComponent, o = r.hookIndex++;
    if (r.hooks[o]) {
      const s = r.hooks[o];
      (t ? !t(s.props, n2) : !shallowEqual(s.props, n2)) && (s.props = n2, s.result = e(n2));
    } else r.hooks[o] = { props: n2, result: e(n2), memoized: true };
    return r.hooks[o].result;
  }
  return n.displayName = `Memo(${e.displayName || e.name || "Component"})`, n.isPure = true, n;
}
function shallowEqual(e, t) {
  if (Object.is(e, t)) return true;
  if ("object" != typeof e || null === e || "object" != typeof t || null === t) return false;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return false;
  for (let r2 = 0; r2 < n.length; r2++) if (!Object.prototype.hasOwnProperty.call(t, n[r2]) || !Object.is(e[n[r2]], t[n[r2]])) return false;
  return true;
}
function createRoot(e) {
  return { render: (t) => {
    enableConcurrentMode(), render(t, e);
  }, unmount: () => {
    for (; e.firstChild; ) e.removeChild(e.firstChild);
    componentStateMap.forEach((e2, t) => {
      cleanupComponent(t);
    }), rootComponent = null, rootContainer = null, previousVDOM = null;
  } };
}
var isBatchingUpdates = false;
var pendingStateUpdates = [];
function batchUpdates(e) {
  const t = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    e();
  } finally {
    if (isBatchingUpdates = t, !isBatchingUpdates && pendingStateUpdates.length > 0) {
      const e2 = [...pendingStateUpdates];
      pendingStateUpdates.length = 0, e2.forEach((e3) => e3()), renderApp();
    }
  }
}
"undefined" != typeof window && (window.Fragment = Fragment, window.createElement = createElement);

export {
  createElement,
  createTextElement,
  setState,
  setReducer,
  setMemo,
  setCallback,
  setEffect,
  createContext,
  setContext,
  setRef,
  Fragment,
  render,
  enableConcurrentMode,
  memo,
  createRoot,
  batchUpdates
};
//# sourceMappingURL=chunk-EDWYJHOS.js.map
