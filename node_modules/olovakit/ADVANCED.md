# Advanced OlovaKit Features

This document showcases the advanced features of OlovaKit and demonstrates the enhanced markdown formatting capabilities.

## Table of Contents

- [Advanced OlovaKit Features](#advanced-olovakit-features)
  - [Table of Contents](#table-of-contents)
  - [Component Composition](#component-composition)
  - [Advanced State Management](#advanced-state-management)
  - [Context API](#context-api)
  - [Performance Optimization](#performance-optimization)
  - [Code Examples](#code-examples)
  - [Styling Components](#styling-components)
  - [Handling Events](#handling-events)
  - [Working with Forms](#working-with-forms)
  - [Conclusion](#conclusion)

## Component Composition

OlovaKit allows you to compose components in a flexible way. Here's how you can create reusable components:

```javascript
// Button.js
export function Button({ children, onClick, className = "" }) {
  return createElement(
    "button",
    { 
      onClick,
      className: `px-4 py-2 bg-blue-500 text-white rounded ${className}`
    },
    children
  );
}

// App.js
import { Button } from './Button';

function App() {
  const [count, setCount] = setState(0);
  
  return createElement("div", null, [
    createElement("h1", null, "Counter App"),
    createElement(Button, { 
      onClick: () => setCount(count + 1),
      className: "hover:bg-blue-600"
    }, `Count: ${count}`)
  ]);
}
```

## Advanced State Management

OlovaKit provides powerful state management capabilities:

> **Note:** State updates are batched for performance. Multiple state updates in the same event handler will be processed together.

### Derived State

You can create derived state using the `setEffect` hook:

```javascript
function TemperatureConverter() {
  const [celsius, setCelsius] = setState(0);
  const [fahrenheit, setFahrenheit] = setState(32);
  
  // Keep fahrenheit in sync with celsius
  setEffect(() => {
    setFahrenheit((celsius * 9/5) + 32);
  }, [celsius]);
  
  // Keep celsius in sync with fahrenheit
  setEffect(() => {
    setCelsius((fahrenheit - 32) * 5/9);
  }, [fahrenheit]);
  
  return createElement("div", null, [
    createElement("div", null, [
      createElement("label", null, "Celsius: "),
      createElement("input", {
        type: "number",
        value: celsius,
        onInput: (e) => setCelsius(Number(e.target.value))
      })
    ]),
    createElement("div", null, [
      createElement("label", null, "Fahrenheit: "),
      createElement("input", {
        type: "number",
        value: fahrenheit,
        onInput: (e) => setFahrenheit(Number(e.target.value))
      })
    ])
  ]);
}
```

## Context API

The Context API allows you to share state across components without prop drilling:

1. Create a context
2. Provide a value
3. Consume the context in child components

```javascript
// Create context
const ThemeContext = createContext('light');

// Provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = setState('light');
  
  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };
  
  return createElement(
    ThemeContext.Provider,
    { value: { theme, toggleTheme } },
    children
  );
}

// Consumer component
function ThemedButton() {
  const { theme, toggleTheme } = setContext(ThemeContext);
  
  return createElement(
    'button',
    { 
      onClick: toggleTheme,
      className: theme === 'light' ? 'bg-white text-black' : 'bg-black text-white'
    },
    `Switch to ${theme === 'light' ? 'dark' : 'light'} mode`
  );
}
```

## Performance Optimization

OlovaKit is designed to be fast by default, but here are some tips for optimizing performance:

* Use proper dependency arrays in `setEffect`
* Avoid creating new functions in render
* Memoize expensive calculations

| Technique | Description | When to use |
|-----------|-------------|-------------|
| Dependency arrays | Only re-run effects when dependencies change | Always |
| Event delegation | Use a single event handler for multiple elements | For lists |
| Batched updates | Group multiple state updates | Automatically applied |

## Code Examples

Here's a more complex example showing a todo list application:

```javascript
function TodoApp() {
  const [todos, setTodos] = setState([]);
  const [newTodo, setNewTodo] = setState('');
  
  const addTodo = () => {
    if (newTodo.trim() === '') return;
    
    setTodos([...todos, {
      id: Date.now(),
      text: newTodo,
      completed: false
    }]);
    setNewTodo('');
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  return createElement('div', null, [
    createElement('h1', null, 'Todo List'),
    createElement('div', { className: 'flex' }, [
      createElement('input', {
        type: 'text',
        value: newTodo,
        onInput: (e) => setNewTodo(e.target.value),
        placeholder: 'Add a new todo',
        className: 'border p-2 flex-grow'
      }),
      createElement('button', {
        onClick: addTodo,
        className: 'bg-blue-500 text-white p-2 ml-2'
      }, 'Add')
    ]),
    createElement('ul', { className: 'mt-4' }, 
      todos.map(todo => 
        createElement('li', { 
          key: todo.id,
          className: 'flex items-center p-2 border-b'
        }, [
          createElement('input', {
            type: 'checkbox',
            checked: todo.completed,
            onChange: () => toggleTodo(todo.id),
            className: 'mr-2'
          }),
          createElement('span', {
            className: todo.completed ? 'line-through text-gray-500' : ''
          }, todo.text),
          createElement('button', {
            onClick: () => deleteTodo(todo.id),
            className: 'ml-auto text-red-500'
          }, 'Delete')
        ])
      )
    )
  ]);
}
```

## Styling Components

OlovaKit works well with various styling approaches:

* **Inline styles**: Pass a style object to elements
* **CSS classes**: Use className prop with utility classes
* **CSS-in-JS**: Integrate with styling libraries

## Handling Events

Event handling in OlovaKit is straightforward:

```javascript
function Form() {
  const [formData, setFormData] = setState({
    name: '',
    email: '',
    message: ''
  });
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form submitted:', formData);
    // Submit to server...
  };
  
  return createElement('form', { onSubmit: handleSubmit }, [
    createElement('div', { className: 'mb-4' }, [
      createElement('label', null, 'Name:'),
      createElement('input', {
        type: 'text',
        name: 'name',
        value: formData.name,
        onChange: handleChange,
        className: 'border p-2 w-full'
      })
    ]),
    // More form fields...
    createElement('button', {
      type: 'submit',
      className: 'bg-green-500 text-white p-2'
    }, 'Submit')
  ]);
}
```

## Working with Forms

OlovaKit makes form handling easy with controlled components:

1. Store form state in state variables
2. Update state on input changes
3. Handle form submission

## Conclusion

OlovaKit provides a simple yet powerful API for building reactive applications. By following the patterns and practices outlined in this guide, you can create efficient, maintainable, and scalable applications.

For more information, check out:

* [API Documentation](/olovakit/API)
* [Getting Started Guide](/olovakit/README)
* [Changelog](/olovakit/CHANGELOG)
